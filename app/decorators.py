import json
import time
from functools import wraps

import jwt
from django.conf import settings
from django.core.exceptions import ValidationError

from .errors import EXPIRED_TOKEN, INVALID_SESSION_ID, INVALID_TOKEN, MISSING_TOKEN, PMError
from .models.conference import Conference
from .models.participant import Participant
from .models.session import Session


def check_initial_authorization(f):
    """
    Method used for checking the JWT token received by the api on session POST. The token should contain a payload in
    the following format, generated by the initialize route:
    {
        'p': <the id of the participant>,
        'c': <the id of the conference>,
        't': <the time when the token was created>,
    }
    The method also checks that the token is signed with the correct secret and that it has not expired.
    """
    @wraps(f)
    def wrapper(*args, **kwargs):
        request = args[1]
        token = request.request_data.get('token')

        if token is None:
            raise PMError(status=401, app_error=MISSING_TOKEN)
        try:
            data = jwt.decode(token, settings.INIT_TOKEN_SECRET)
        except (jwt.DecodeError, IndexError, AttributeError):
            raise PMError(status=401, app_error=INVALID_TOKEN)

        try:
            if time.time() - data['t'] > settings.INIT_TOKEN_LIFESPAN:
                raise PMError(status=401, app_error=EXPIRED_TOKEN)
            participant = Participant.get(id=data['p'])
            conference = Conference.get(id=data['c'])
        except (KeyError, TypeError, ValidationError, Participant.DoesNotExist, Conference.DoesNotExist):
            raise PMError(status=401, app_error=INVALID_TOKEN)
        else:
            request.participant = participant
            request.conference = conference

        return f(*args, **kwargs)
    return wrapper


def check_authorization(f):
    """
    Method used for checking the JWT token received by the api on requests from the sdk. The token should contain a
    payload in the following format, generated by the session route:
    {
        's': <the id of the session>,
        't': <the time when the token was created>,
    }
    The method also checks that the token is signed with the correct secret and that it has not expired.
    """
    @wraps(f)
    def wrapper(*args, **kwargs):
        request = args[1]
        token = request.request_data.get('token')

        if token is None:
            raise PMError(status=401, app_error=MISSING_TOKEN)
        try:
            data = jwt.decode(token, settings.SESSION_TOKEN_SECRET)
        except (jwt.DecodeError, IndexError, AttributeError):
            raise PMError(status=401, app_error=INVALID_TOKEN)

        try:
            if time.time() - data['t'] > settings.SESSION_TOKEN_LIFESPAN:
                raise PMError(status=401, app_error=EXPIRED_TOKEN)
            peer_session = Session.get(id=data['s'])
        except (KeyError, TypeError, ValidationError, Session.DoesNotExist):
            raise PMError(status=401, app_error=INVALID_TOKEN)
        else:
            request.peer_session = peer_session

        return f(*args, **kwargs)
    return wrapper

def check_request_body(f):
    """
    Method used for checking the received body from the request is a valid JSON.
    """
    @wraps(f)
    def wrapper(*args, **kwargs):
        request = args[1]
        try:
            request.request_data = json.loads(request.body.decode('utf-8'))
        except json.decoder.JSONDecodeError:
            raise PMError(status=400)
        return f(*args, **kwargs)
    return wrapper
